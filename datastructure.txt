Binary Tree
	Interview Skill
		#1: What do I already know:
			Tree is also a graph, an acyclic connected graph
	Height
		the largest # of edges in a path from a leaf node to a target node 
	Balanced Binary Tree
		the left and right subtrees of every node differ in height by no more 			     
                than 1
	Recursive Approach
		Policy #1: What need to happen just in "Single Node"
		Policy #2: Base Case
		
Least Recently Used (LRU) cache
	Data Structure Implementations:
		1. Queue, suing a double linked list. 
		2. A Hash, with page number as key and address of the corresponding queue node as value.
	Paging
		a memory management scheme
		break physical memory into fixed-size blocks called frames and logical memory into blocks of same size called pages.
	Reference a page
		If the page is in the memory: 
			detach the node of the list and bring it to the front of the queue.
		else:
			add a new node to the front of the queue
			update the corresponding node address in the hash
			if the queue is full
				remove a node from the rear of the queue
				add the new node to the front of the queue

Common Sorting Algorithms
	Merge Sort: 
		Runtime O(n log(n)) average and worst case
		Memory: depends
	Quick Sort:
		Runtime O(n log(n)) average, O(n^2) worst case
		Memory: O(log(n))

Topological Sorting
	A linear ordering version of Directed Acyclic Graph(DAG)

Integer.MAX_VALUE: 2^31 - 1

Integer.MIN_VALUE: -2^31

Arrays
	Arrays.equal(char[] a, char[] b): Returns true if the two specified arrays of bytes are equal to one another
	Arrays.sort(char[] a): return type "static void"
	Arrays.asList(T...a): static <T> List<T>
		return a fixed-size list backed by the specified array.  

Strings
	toCharArray(): Converts this string to a new character array
	toString(): This object (which is already a string) is itself return
	valueOf(char c): Returns the string representation of the char argument 
	values(): Return a Collection view of the values contained in this map

Backtracking
	Keys
		1. Choice: A decision point in the recursion
		2. Constraints: cannot do a decision 
		3. Goal: final result

Sliding Window
	"start" and "end" for the two edge of the window

HashMap
	contains: T O(1)
	get(): Returns the value to which the specified key is mapped, or null if no mapping

Difference between break and continue
	break: end the loop immediately
	continue: skip the current iteration of the loop

Binary Search
	cut the elements is half, if target==mid elements, return; else, recursively search in the first half and second half.
